<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".generated.cs" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Windows.Forms" #>
<#@ assembly name="$(SolutionDir)\UnitySpine.Runtime\bin\Debug\UnitySpine.Runtime.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ import namespace="UnitySpine.Runtime.Spine.Runtime.Data" #>
<#@ import namespace="System.Reflection" #>
<#
   // insert your template code here the tempalte code will be syntaxhighlighted 
   // and you will have intellisense for all namespaces in the full edition
    var assembly = typeof(SpineData).Assembly;
    var types = assembly.GetTypes()
                    .Where(t => t.Namespace.Contains("UnitySpine.Runtime.Spine.Runtime.Data") 
                    && !t.Name.Contains("SerializableReadOnlyDictionary") 
                    && !t.Name.Contains("SerializableReadOnlyCollection")
                    && !t.IsSubclassOf(typeof(Enum))
                    && !t.IsAbstract)
                    .ToArray();
    var nameSpaces = types.Select(e => e.Namespace).Distinct();
#>
// This is the output code from your template
// you only get syntax-highlighting here - not intellisense
using System;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using UnitySpine.Editor.Spine.Editor.JSONExtention;

<#
    foreach(var ns in nameSpaces)    
    {
 #>
using <#=ns#> ;
<#
    }
 #>

//generated classes <#= types.Length #>

namespace UnitySpine.Editor.Spine.Editor.JSONConverter
{
<#
    foreach(var type in types)
    {
        if(type.BaseType.Name.Contains("SerializableReadOnlyDictionary"))
        {
            var valueType = type.BaseType.GetGenericArguments()[1];
#>
    //Type: <#=type.Name #> BaseType: <#=type.BaseType.Name #>
    public class <#=type.Name#>_Generated_JsonConverter :BaseSpineSerializableReadOnlyDictionaryJsonConverter<<#=valueType.Name#>>
    {
    }
<#
        }
        else if(type.BaseType.Name.Contains("SerializableReadOnlyCollection"))
        {
            var valueType = type.BaseType.GetGenericArguments()[0];
#>
 
    //Type: <#=type.Name #> BaseType: <#=type.BaseType.Name #>
    public class <#=type.Name#>_Generated_JsonConverter :BaseSpineSerializableReadOnlyCollectionJsonConverter<<#=valueType.Name#>>
    {
    }
<#
        }
        else
        {
        var fields = new List<FieldInfo>();
        if(!type.BaseType.Name.Contains("Object"))
        {
            fields.AddRange(type.BaseType.GetFields(BindingFlags.Instance | BindingFlags.NonPublic));
        }
        fields.AddRange(type.GetFields(BindingFlags.Instance | BindingFlags.NonPublic));        
 #>
    //Type: <#=type.Name #> BaseType: <#=type.BaseType.Name #>
    public class <#=type.Name#>_Generated_JsonConverter : BaseSpineJsonConverter<<#=type.Name#>>
    {
         public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (JsonToken.Null == reader.TokenType) return null;
            var jsonArray = JArray.Load(reader);
<#        foreach(var field in fields)        { #>
<#                if(field.FieldType.Name.Contains("Color")){ #>
            var <#=field.Name #> = jsonArray.TryGetColor("<#=field.Name.Replace("_","")#>", serializer,"#ffffffff");
<#                }else if(field.FieldType.IsSubclassOf(typeof(Enum))) {#>
            var <#=field.Name #> = jsonArray.TryGetEnum<<#=field.FieldType.Name#>>("<#=field.Name.Replace("_","")#>", serializer, <#=field.FieldType.Name#>.<#=Enum.GetNames(field.FieldType)[0]#>);
<#                }else{ #>
<#                    if(field.FieldType.Name.Contains("List")) {#>
<#                        var listGenericParam = field.FieldType.GetGenericArguments()[0];#>
            var <#=field.Name #> = jsonArray.TryGet<<#=listGenericParam.Name#>[]>("<#=field.Name.Replace("_","")#>", serializer);
<#                    } else {#>
            var <#=field.Name #> = jsonArray.TryGet<<#=field.FieldType.Name#>>("<#=field.Name.Replace("_","")#>", serializer);
<#                                } #>
<#                          } #>
<#         } #>
            
            return new <#=type.Name #>(
<#        foreach(var field in fields)        { #>
            <#=field.Name#><# if(field.FieldType.Name.Contains("List")){#>.ToList()<#}#><#if(fields.Last()!= field) {#>,<#}#>

<#        } #>
            );  
        }
     }
<#      } #>  

<#} #>
}
 
